# handlers/beer_tracking.py
import logging
import os
from typing import Optional, List, Tuple
from telegram import Update, Message, PhotoSize, InlineKeyboardButton, InlineKeyboardMarkup # Added InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    ContextTypes,
    MessageHandler,
    filters,
    ConversationHandler,
    CommandHandler,
    CallbackQueryHandler, # Added CallbackQueryHandler
)
from db_utils import add_or_update_user, add_beer_entry, get_db, get_user_total_volume
from config import GROUP_CHAT_ID  # –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º ID –≥—Ä—É–ø–ø–æ–≤–æ–≥–æ —á–∞—Ç–∞
from handlers.achievements import check_new_achievement, format_achievement_message

# Enable logging
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)

# Define conversation states
AWAITING_VOLUME_CHOICE = 1 # Renamed state

async def handle_photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handles incoming photos, stores file_id, and asks for volume via buttons."""
    message: Optional[Message] = update.message
    user = message.from_user
    photo: Optional[Tuple[PhotoSize, ...]] = message.photo

    if not photo:
        logger.warning("Received message with photo filter but no photo.")
        # Decide how to handle this - maybe end conversation or ask again?
        return ConversationHandler.END # Or another appropriate state/action

    photo_file_id = photo[-1].file_id # Get the highest resolution photo
    logger.info(f"Received photo from {user.first_name} ({user.id}). File ID: {photo_file_id}")

    # Store photo file_id for the next step
    context.user_data['photo_file_id'] = photo_file_id

    # Define the volume options
    keyboard = [
        [InlineKeyboardButton("0.3 –ª", callback_data='0.3'), InlineKeyboardButton("0.4 –ª", callback_data='0.4')],
        [InlineKeyboardButton("0.5 –ª", callback_data='0.5'), InlineKeyboardButton("1.0 –ª", callback_data='1.0')],
        [InlineKeyboardButton("1.5 –ª", callback_data='1.5'), InlineKeyboardButton("2.0 –ª", callback_data='2.0')],
        [InlineKeyboardButton("–û—Ç–º–µ–Ω–∞", callback_data='cancel_volume')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await message.reply_text(
        "–§–æ—Ç–æ –ø–æ–ª—É—á–∏–ª! üëç –¢–µ–ø–µ—Ä—å –≤—ã–±–µ—Ä–∏ –æ–±—ä–µ–º –≤—ã–ø–∏—Ç–æ–≥–æ –ø–∏–≤–∞:",
        reply_markup=reply_markup
    )

    return AWAITING_VOLUME_CHOICE # Transition to the state waiting for button press

async def handle_volume_choice(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handles the volume button press, saves the entry, and ends the conversation."""
    query = update.callback_query
    await query.answer() # Answer the callback query first

    user = query.from_user
    volume_data = query.data
    photo_file_id = context.user_data.get('photo_file_id')

    if volume_data == 'cancel_volume':
        logger.info(f"User {user.first_name} ({user.id}) canceled volume selection.")
        if 'photo_file_id' in context.user_data:
            del context.user_data['photo_file_id']
        await query.edit_message_text(text="–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –ø–∏–≤–∞ –æ—Ç–º–µ–Ω–µ–Ω–æ.")
        return ConversationHandler.END

    if not user or not photo_file_id:
        logger.warning("User or photo_file_id missing in handle_volume_choice.")
        await query.edit_message_text(text="–ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫. –ü–æ–ø—Ä–æ–±—É–π –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Ñ–æ—Ç–æ –µ—â–µ —Ä–∞–∑.")
        # Clear data if something is wrong
        if 'photo_file_id' in context.user_data:
            del context.user_data['photo_file_id']
        return ConversationHandler.END

    try:
        volume = float(volume_data)
    except ValueError:
        logger.error(f"Invalid volume data received from callback: {volume_data}")
        await query.edit_message_text(text="–ü—Ä–æ–∏–∑–æ—à–ª–∞ –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
        if 'photo_file_id' in context.user_data:
            del context.user_data['photo_file_id']
        return ConversationHandler.END

    # Save to database
    try:
        with next(get_db()) as db:
            # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–π –æ–±—ä–µ–º –≤—ã–ø–∏—Ç–æ–≥–æ –ø–∏–≤–∞ –ø–µ—Ä–µ–¥ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ–º –Ω–æ–≤–æ–π –∑–∞–ø–∏—Å–∏
            old_volume = get_user_total_volume(db, user.id)
            
            db_user = add_or_update_user(db, user_id=user.id, first_name=user.first_name, username=user.username)
            add_beer_entry(db, user_id=db_user.id, volume=volume, photo_id=photo_file_id)
            
            # –ü–æ–ª—É—á–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π –æ–±—ä–µ–º –ø–æ—Å–ª–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è
            new_volume = get_user_total_volume(db, user.id)

        # –°–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
        await query.edit_message_text(
            text=f"–û—Ç–ª–∏—á–Ω–æ! –ó–∞—Å—á–∏—Ç–∞–Ω–æ {volume:.2f} –ª –ø–∏–≤–∞. üçª"
        )
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ñ–æ—Ç–æ –∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –≤ –≥—Ä—É–ø–ø–æ–≤–æ–π —á–∞—Ç
        if GROUP_CHAT_ID:
            username = f"@{user.username}" if user.username else user.first_name
            caption = f"üç∫ {username} –≤—ã–ø–∏–ª(–∞) {volume:.2f} –ª –ø–∏–≤–∞! üçª"
            try:
                await context.bot.send_photo(
                    chat_id=GROUP_CHAT_ID,
                    photo=photo_file_id,
                    caption=caption
                )
                logger.info(f"Beer submission forwarded to group chat: {GROUP_CHAT_ID}")
            except Exception as e:
                logger.error(f"Failed to forward submission to group chat: {e}", exc_info=True)
        else:
            logger.warning("GROUP_CHAT_ID not set, cannot forward beer submission")
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        new_achievement = check_new_achievement(old_volume, new_volume)
        if new_achievement:
            username_display = f"@{user.username}" if user.username else user.first_name
            achievement_message = format_achievement_message(new_achievement, username_display)
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –æ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
            try:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —Ñ–∞–π–ª –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
                if os.path.exists(new_achievement['image']):
                    with open(new_achievement['image'], 'rb') as photo:
                        await context.bot.send_photo(
                            chat_id=user.id,
                            photo=photo,
                            caption=achievement_message
                        )
                else:
                    # –ï—Å–ª–∏ —Ñ–∞–π–ª –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
                    await context.bot.send_message(
                        chat_id=user.id,
                        text=achievement_message
                    )
                    logger.warning(f"Achievement image not found: {new_achievement['image']}")
            except Exception as e:
                logger.error(f"Failed to send achievement to user: {e}", exc_info=True)
                # –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç
                await context.bot.send_message(
                    chat_id=user.id,
                    text=achievement_message
                )
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –æ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–∏ –≤ –≥—Ä—É–ø–ø–æ–≤–æ–π —á–∞—Ç
            if GROUP_CHAT_ID:
                try:
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —Ñ–∞–π–ª –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
                    if os.path.exists(new_achievement['image']):
                        with open(new_achievement['image'], 'rb') as photo:
                            await context.bot.send_photo(
                                chat_id=GROUP_CHAT_ID,
                                photo=photo,
                                caption=achievement_message
                            )
                    else:
                        # –ï—Å–ª–∏ —Ñ–∞–π–ª –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
                        await context.bot.send_message(
                            chat_id=GROUP_CHAT_ID,
                            text=achievement_message
                        )
                    logger.info(f"Achievement notification sent to group chat: {GROUP_CHAT_ID}")
                except Exception as e:
                    logger.error(f"Failed to send achievement notification to group chat: {e}", exc_info=True)
                    # –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç
                    try:
                        await context.bot.send_message(
                            chat_id=GROUP_CHAT_ID,
                            text=achievement_message
                        )
                    except:
                        pass
        
        logger.info(f"Successfully added entry for user {user.id}: {volume}L")
        # Clear stored data
        del context.user_data['photo_file_id']
        return ConversationHandler.END

    except Exception as e:
        logger.error(f"Database error while adding beer entry for user {user.id}: {e}", exc_info=True)
        await query.edit_message_text(text="–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö. –ü–æ–ø—Ä–æ–±—É–π –ø–æ–∑–∂–µ.")
        # Clear stored data even on error
        if 'photo_file_id' in context.user_data:
             del context.user_data['photo_file_id']
        return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Cancels and ends the conversation (used by /cancel command)."""
    user = update.message.from_user
    logger.info(f"User {user.first_name} ({user.id}) canceled the conversation via command.")
    # Clear stored data if any
    if 'photo_file_id' in context.user_data:
        del context.user_data['photo_file_id']

    await update.message.reply_text(
        '–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –ø–∏–≤–∞ –æ—Ç–º–µ–Ω–µ–Ω–æ.'
    )
    return ConversationHandler.END

# Conversation handler for beer tracking
beer_tracking_conv_handler = ConversationHandler(
    entry_points=[MessageHandler(filters.PHOTO & ~filters.COMMAND, handle_photo)],
    states={
        AWAITING_VOLUME_CHOICE: [CallbackQueryHandler(handle_volume_choice)], # Use CallbackQueryHandler
    },
    fallbacks=[CommandHandler('cancel', cancel), CallbackQueryHandler(handle_volume_choice, pattern='^cancel_volume$')], # Also handle cancel button
    per_user=True, # Default, but explicit
    per_chat=True  # Add this for better group chat handling
)